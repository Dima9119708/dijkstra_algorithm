{"version":3,"sources":["algorithms/dijkstra.js","PathfindingVisualizer/node/Node.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["sortNodes","unvisitedNodes","sort","nodeA","nodeB","distance","watchingUpdateNeighbors","node","grid","unvisitedNeighbors","neighbors","col","row","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","previousNode","Node","nodes","map","i","className","isStart","isFinish","isWall","id","item","split","PathfindingVisualizer","React","useState","initGrid","setGrid","useEffect","countRow","countCol","currentRow","createNode","getInitialGrid","animationAllNodes","allVisitedNodes","path","forEach","setTimeout","document","getElementById","classList","add","animationPath","onClick","startNode","finishNode","visitedNodes","flat","currentNode","shift","Infinity","dijkstra","minPath","prevNode","nextNode","overlapColRow1","overlapColRow2","splice","getMinPath","unshift","getNodesInShortestPathOrder","style","width","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.853b2695.chunk.js","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\r\n\r\n  const visitedNodes = [];\r\n\r\n  startNode.distance = 0;\r\n\r\n  const unvisitedNodes = grid.flat()\r\n\r\n  while (unvisitedNodes.length) {\r\n\r\n    sortNodes(unvisitedNodes);\r\n\r\n    const currentNode = unvisitedNodes.shift();\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    currentNode.isVisited = true;\r\n    visitedNodes.push(currentNode);\r\n\r\n    if (currentNode.distance === Infinity) return visitedNodes\r\n\r\n    if (currentNode === finishNode) return visitedNodes;\r\n\r\n    watchingUpdateNeighbors(currentNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodes(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction watchingUpdateNeighbors(node, grid) {\r\n\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n\r\n  const path = [];\r\n  let currentNode = finishNode;\r\n\r\n  while (currentNode !== null) {\r\n    path.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\n\r\nexport function getMinPath (path) {\r\n\r\n  const minPath = [...path]\r\n\r\n  for ( let i = 0; i < minPath.length; i++ ) {\r\n\r\n    const prevNode = minPath[i - 1]\r\n    const currentNode = minPath[i]\r\n    const nextNode = minPath[i + 1]\r\n\r\n    const overlapColRow1 = currentNode.col === nextNode?.col\r\n                           &&\r\n                           currentNode.row === prevNode?.row\r\n    // Пример\r\n    // { row : 0, col : 4} prevNode\r\n    //         +\r\n    //         +\r\n    // { row : 0, col : 5} currentNode\r\n    //                  +\r\n    //                  +\r\n    // { row : 1, col : 5} nextNode\r\n\r\n\r\n    const overlapColRow2 = currentNode.row === nextNode?.row\r\n                           &&\r\n                           currentNode.col === prevNode?.col\r\n    // Пример\r\n    // { row : 1, col : 5} prevNode\r\n    //                  +\r\n    //                  +\r\n    // { row : 2, col : 5} currentNode\r\n    //         +\r\n    //         +\r\n    // { row : 2, col : 5} nextNode\r\n\r\n\r\n    if (overlapColRow1 || overlapColRow2) minPath.splice(i, 1)\r\n  }\r\n\r\n  return minPath\r\n}","import React from 'react'\r\nimport './node.css'\r\n\r\nexport const Node = ( { nodes } ) => {\r\n\r\n  return <>\r\n    {\r\n      nodes.map( (node, i) => {\r\n\r\n        return <div\r\n          key={i}\r\n          className={`node\r\n                    ${node.isStart ? 'node-start' : ''}\r\n                    ${node.isFinish ? 'node-finish' : ''}\r\n                    ${node.isWall ? 'node-wall' : '' }`\r\n                  }\r\n          id={ node.row + '-' + node.col }\r\n        />\r\n\r\n      })\r\n    }\r\n  </>\r\n}","import React from 'react'\r\nimport {dijkstra, getMinPath, getNodesInShortestPathOrder} from '../algorithms/dijkstra'\r\nimport { Node } from './node/Node'\r\nimport './pathfindingVisualizer.css'\r\n\r\nconst grid = [\r\n  '..................',\r\n  '.XXXXXXXX.........',\r\n  '..................',\r\n  '......XXXXXX......',\r\n  '....XX......XX....',\r\n  '..................',\r\n  '..................',\r\n  '..................',\r\n  '..................',\r\n  '..................',\r\n].map(item => item.split(''))\r\n\r\nconst startX = 9\r\nconst startY = 2\r\n\r\nconst endX = 0\r\nconst endY = 7\r\n\r\n\r\nexport const PathfindingVisualizer = () => {\r\n\r\n  const [initGrid, setGrid] = React.useState([])\r\n\r\n\r\n  React.useEffect(() => {\r\n\r\n    const countRow = grid.length\r\n    const countCol = grid[0].length\r\n\r\n    const initGrid = getInitialGrid(countRow, countCol)\r\n    setGrid(initGrid)\r\n\r\n  }, [])\r\n\r\n\r\n  const animationPath = (path) => {\r\n    path.forEach((item, i) => {\r\n\r\n      setTimeout(() => {\r\n\r\n        document\r\n          .getElementById(`${item.row}-${item.col}`)\r\n          .classList\r\n          .add('node-path')\r\n\r\n      }, 50 * i)\r\n\r\n    })\r\n  }\r\n\r\n\r\n  const animationAllNodes = (allVisitedNodes, path) => {\r\n\r\n    allVisitedNodes.forEach((item, i) => {\r\n\r\n      if (item.isFinish) {\r\n        setTimeout(() => animationPath(path), 10 * allVisitedNodes.length)\r\n      }\r\n\r\n      setTimeout(() => {\r\n\r\n        document\r\n          .getElementById(`${item.row}-${item.col}`)\r\n          .classList\r\n          .add('node-visited')\r\n\r\n      }, 10 * i)\r\n\r\n    })\r\n  }\r\n\r\n  const handleClick = () => {\r\n\r\n    const startNode = initGrid[startX][startY]\r\n    const finishNode = initGrid[endX][endY]\r\n\r\n    const allVisitedNodes = dijkstra(initGrid, startNode, finishNode)\r\n    const path = getNodesInShortestPathOrder(finishNode)\r\n    const minPath = getMinPath(path)\r\n\r\n    animationAllNodes(allVisitedNodes, minPath)\r\n  }\r\n\r\n\r\n  return (\r\n    <div >\r\n\r\n      <button\r\n        onClick={handleClick}\r\n        className=\"button\"\r\n      >\r\n        Алгоритм Дейкстры\r\n      </button>\r\n\r\n      <div\r\n        style={ { width: grid[0].length * 30 } }\r\n        className=\"nodes\"\r\n      >\r\n\r\n        { initGrid.map((item, i) => <Node key={i} nodes={item} />) }\r\n\r\n      </div>\r\n\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\nfunction getInitialGrid(countRow, countCol) {\r\n\r\n  const grid = []\r\n\r\n  for (let row = 0; row < countRow; row++) {\r\n\r\n    const currentRow = []\r\n\r\n    for (let col = 0; col < countCol; col++) {\r\n      currentRow.push(createNode(col, row))\r\n    }\r\n\r\n    grid.push(currentRow)\r\n  }\r\n\r\n  return grid\r\n}\r\n\r\n\r\nfunction createNode(col, row) {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === startX && col === startY,\r\n    isFinish: row === endX && col === endY,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: grid[row][col] === 'X' ? true : false,\r\n    previousNode: null,\r\n  }\r\n}","import './App.css';\r\nimport { PathfindingVisualizer } from './PathfindingVisualizer/PathfindingVisualizer';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}