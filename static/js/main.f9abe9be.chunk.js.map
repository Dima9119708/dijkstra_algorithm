{"version":3,"sources":["algorithms/dijkstra.js","PathfindingVisualizer/node/Node.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["sortNodes","unvisitedNodes","sort","nodeA","nodeB","distance","watchingUpdateNeighbors","node","grid","unvisitedNeighbors","neighbors","col","row","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","previousNode","Node","nodes","map","i","className","isStart","isFinish","isWall","id","item","split","PathfindingVisualizer","React","useState","initGrid","setGrid","useEffect","countRow","countCol","currentRow","createNode","getInitialGrid","animationAllNodes","allVisitedNodes","path","forEach","setTimeout","document","getElementById","classList","add","animationPath","onClick","startNode","finishNode","visitedNodes","flat","currentNode","shift","Infinity","dijkstra","unshift","getNodesInShortestPathOrder","style","width","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.f9abe9be.chunk.js","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\r\n\r\n  const visitedNodes = [];\r\n\r\n  startNode.distance = 0;\r\n\r\n  const unvisitedNodes = grid.flat()\r\n\r\n  while (unvisitedNodes.length) {\r\n\r\n    sortNodes(unvisitedNodes);\r\n\r\n    const currentNode = unvisitedNodes.shift();\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    currentNode.isVisited = true;\r\n    visitedNodes.push(currentNode);\r\n\r\n    if (currentNode.distance === Infinity) return visitedNodes\r\n\r\n    if (currentNode === finishNode) return visitedNodes;\r\n\r\n    watchingUpdateNeighbors(currentNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodes(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction watchingUpdateNeighbors(node, grid) {\r\n\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n\r\n  const path = [];\r\n  let currentNode = finishNode;\r\n\r\n  while (currentNode !== null) {\r\n    path.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return path;\r\n}","import React from 'react'\r\nimport './node.css'\r\n\r\nexport const Node = ( { nodes } ) => {\r\n\r\n  return <>\r\n    {\r\n      nodes.map( (node, i) => {\r\n\r\n        return <div\r\n          key={i}\r\n          className={`node\r\n                    ${node.isStart ? 'node-start' : ''}\r\n                    ${node.isFinish ? 'node-finish' : ''}\r\n                    ${node.isWall ? 'node-wall' : '' }`\r\n                  }\r\n          id={ node.row + '-' + node.col }\r\n        />\r\n\r\n      })\r\n    }\r\n  </>\r\n}","import React from 'react'\r\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra'\r\nimport { Node } from './node/Node'\r\nimport './pathfindingVisualizer.css'\r\n\r\nconst gridList = [\r\n  '..................',\r\n  '.XXXXXXXX.........',\r\n  '..................',\r\n  '......XXXXXX......',\r\n  '....XX......XX....',\r\n  '..................',\r\n  '..................',\r\n  '..................',\r\n  '..................',\r\n  '..................',\r\n]\r\n\r\nconst grid = gridList.map(item => item.split(''))\r\n\r\nconst startX = 9\r\nconst startY = 8\r\n\r\nconst endX = 0\r\nconst endY = 8\r\n\r\n\r\nexport const PathfindingVisualizer = () => {\r\n\r\n  const [initGrid, setGrid] = React.useState([])\r\n\r\n\r\n  React.useEffect(() => {\r\n\r\n    const countRow = grid.length\r\n    const countCol = grid[0].length\r\n\r\n    const initGrid = getInitialGrid(countRow, countCol)\r\n    setGrid(initGrid)\r\n\r\n  }, [])\r\n\r\n\r\n  const animationPath = (path) => {\r\n    path.forEach((item, i) => {\r\n\r\n      setTimeout(() => {\r\n\r\n        document\r\n          .getElementById(`${item.row}-${item.col}`)\r\n          .classList\r\n          .add('node-path')\r\n\r\n      }, 50 * i)\r\n\r\n    })\r\n  }\r\n\r\n\r\n  const animationAllNodes = (allVisitedNodes, path) => {\r\n\r\n    allVisitedNodes.forEach((item, i) => {\r\n\r\n      if (item.isFinish) {\r\n        setTimeout(() => animationPath(path), 10 * allVisitedNodes.length)\r\n      }\r\n\r\n      setTimeout(() => {\r\n\r\n        document\r\n          .getElementById(`${item.row}-${item.col}`)\r\n          .classList\r\n          .add('node-visited')\r\n\r\n      }, 10 * i)\r\n\r\n    })\r\n  }\r\n\r\n  const handleClick = () => {\r\n\r\n    const startNode = initGrid[startX][startY]\r\n    const finishNode = initGrid[endX][endY]\r\n\r\n    const allVisitedNodes = dijkstra(initGrid, startNode, finishNode)\r\n    const path = getNodesInShortestPathOrder(finishNode)\r\n\r\n    animationAllNodes(allVisitedNodes, path)\r\n  }\r\n\r\n\r\n  return (\r\n    <div >\r\n\r\n      <button\r\n        onClick={handleClick}\r\n        className=\"button\"\r\n      >\r\n        Алгоритм Дейкстры\r\n      </button>\r\n\r\n      <div\r\n        style={ { width: grid[0].length * 30 } }\r\n        className=\"nodes\"\r\n      >\r\n\r\n        { initGrid.map((item, i) => <Node key={i} nodes={item} />) }\r\n\r\n      </div>\r\n\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\nfunction getInitialGrid(countRow, countCol) {\r\n\r\n  const grid = []\r\n\r\n  for (let row = 0; row < countRow; row++) {\r\n\r\n    const currentRow = []\r\n\r\n    for (let col = 0; col < countCol; col++) {\r\n      currentRow.push(createNode(col, row))\r\n    }\r\n\r\n    grid.push(currentRow)\r\n  }\r\n\r\n  return grid\r\n}\r\n\r\n\r\nfunction createNode(col, row) {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === startX && col === startY,\r\n    isFinish: row === endX && col === endY,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: grid[row][col] === 'X' ? true : false,\r\n    previousNode: null,\r\n  }\r\n}","import './App.css';\nimport { PathfindingVisualizer } from './PathfindingVisualizer/PathfindingVisualizer';\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}